#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    liftPotent,     sensorPotentiometer)
#pragma config(Sensor, in2,    mogoPotent,     sensorPotentiometer)
#pragma config(Sensor, in3,    clawPotent,     sensorPotentiometer)
#pragma config(Sensor, I2C_1,  leftBaseEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  rightBaseEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  rightChainBarEncoder, sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           clawMotor,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftBase,      tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           rightBase,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,           liftSet1,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           liftSet2,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           leftMogo,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightMogo,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           leftChainBar,  tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           rightChainBar, tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()
{

	bool Phase1BaseMovementIsNotDone = true;
	bool Phase1LiftMovementIsNotDone = true;

	SensorValue[leftBaseEncoder] = 0;
	SensorValue[rightBaseEncoder] = 0;

	while(Phase1BaseMovementIsNotDone || Phase1LiftMovementIsNotDone) //Phase 1
	{

		if(fabs(SensorValue[leftBaseEncoder]) <= 610 && fabs(SensorValue[rightBaseEncoder]) <= 610) //Base moving
		{

			Phase1BaseMovementIsNotDone = false;

		}

		else
		{

			motor[leftBase] = 115;
			motor[rightBase] = 115;

		}

		if(SensorValue[liftPotent]) //Lift lifting
		{

			Phase1LiftMovementIsNotDone = false;

		}

		else
		{

			motor[liftSet1] = -120;
			motor[liftSet1] = -120;

		}

	}

	SensorValue[leftBaseEncoder] = 0;
	SensorValue[rightBaseEncoder] = 0;

	motor[clawMotor] = 0;
	motor[leftBase] = 0;
	motor[rightBase] = 0;
	motor[liftSet1] = 0;
	motor[liftSet2] = 0;
	motor[leftMogo] = 0;
	motor[rightMogo] = 0;
	motor[leftChainBar] = 0;
	motor[rightChainBar] = 0;
	wait1Msec(100);

	while(SensorValue[rightChainBarEncoder] < 310)
	{

		motor[leftChainBar] = -70;
		motor[rightChainBar] = -70;

	}

	motor[clawMotor] = 0;
	motor[leftBase] = 0;
	motor[rightBase] = 0;
	motor[liftSet1] = 0;
	motor[liftSet2] = 0;
	motor[leftMogo] = 0;
	motor[rightMogo] = 0;
	motor[leftChainBar] = 0;
	motor[rightChainBar] = 0;
	wait1Msec(100);

	while(SensorValue[clawPotent] < 2245)
	{

		motor[clawMotor] = 50;

	}

	motor[clawMotor] = 0;
	motor[leftBase] = 0;
	motor[rightBase] = 0;
	motor[liftSet1] = 0;
	motor[liftSet2] = 0;
	motor[leftMogo] = 0;
	motor[rightMogo] = 0;
	motor[leftChainBar] = 0;
	motor[rightChainBar] = 0;
	wait1Msec(100);

	while(SensorValue[rightChainBarEncoder] > 50)
	{

		motor[leftChainBar] = 100;
		motor[rightChainBar] = 100;

	}

	SensorValue[leftBaseEncoder] = 0;
	SensorValue[rightBaseEncoder] = 0;
	motor[clawMotor] = 0;
	motor[leftBase] = 0;
	motor[rightBase] = 0;
	motor[liftSet1] = 0;
	motor[liftSet2] = 0;
	motor[leftMogo] = 0;
	motor[rightMogo] = 0;
	motor[leftChainBar] = 0;
	motor[rightChainBar] = 0;
	wait1Msec(100);	//Preload cone already stacked. We need to go to mogo.

	/* This is rest of code:

	while(fabs(SensorValue[leftBaseEncoder]) <= 486.15 && fabs(SensorValue[rightBaseEncoder]) <= 486.15) //Phase 3
	{

		motor[leftBase] = -115;
		motor[rightBase] = -115;

	}

	SensorValue[leftBaseEncoder] = 0;
	SensorValue[rightBaseEncoder] = 0;
	motor[clawMotor] = 0;
	motor[leftBase] = 0;
	motor[rightBase] = 0;
	motor[liftSet1] = 0;
	motor[liftSet2] = 0;
	motor[leftMogo] = 0;
	motor[rightMogo] = 0;
	motor[leftChainBar] = 0;
	motor[rightChainBar] = 0;
	wait1Msec(100);

	while(fabs(SensorValue[leftBaseEncoder]) <= 266.45 && fabs(SensorValue[rightBaseEncoder]) <= 266.45) //Phase 4
	{
		motor[leftBase] = 115;
		motor[rightBase]= -115;
	}

	SensorValue[leftBaseEncoder] = 0;
	SensorValue[rightBaseEncoder] = 0;
	motor[clawMotor] = 0;
	motor[leftBase] = 0;
	motor[rightBase] = 0;
	motor[liftSet1] = 0;
	motor[liftSet2] = 0;
	motor[leftMogo] = 0;
	motor[rightMogo] = 0;
	motor[leftChainBar] = 0;
	motor[rightChainBar] = 0;
	wait1Msec(100);

	bool Phase5BaseMovementIsNotDone = true;
	bool Phase5LiftMovementIsNotDone = true;

	while(Phase5BaseMovementIsNotDone || Phase5LiftMovementIsNotDone) //Phase 5
	{

		if(fabs(SensorValue[leftBaseEncoder]) <= 2091.1 && fabs(SensorValue[rightBaseEncoder]) <= 2091.1) //Base moving
		{

			Phase1BaseMovementIsNotDone = false;

		}

		else
		{

			motor[leftBase] = 115;
			motor[rightBase] = 115;

		}

		if(SensorValue[liftPotent])
		{

			Phase1LiftMovementIsNotDone = false;

		}

		else
		{

			motor[liftSet1] = 60;
			motor[liftSet1] = 60;

		}

	}

	*/

}
